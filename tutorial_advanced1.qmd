# Python for Applied Mechanics {#sec-applied-mechanics-tutorial}

This tutorial extends the foundational and advanced Python concepts from previous tutorials, tailoring them to applied mechanics in engineering. It focuses on using NumPy for numerical computations involving vectors and matrices (e.g., forces, stresses), Matplotlib for visualizing mechanics data (e.g., stress-strain curves, motion plots), and integrates these with Pint for unit-aware calculations. Examples are drawn from statics, dynamics, and mechanics of materials. Assume Pint, NumPy, and Matplotlib are installed in your virtual environment (as covered in the advanced tutorial).

## Requirements

Build on the advanced tutorial: Activate your virtual environment and ensure the following libraries are installed via `pip install numpy matplotlib scipy pint`. SciPy is included for numerical methods like solving differential equations.

## NumPy for Vectors and Matrices in Mechanics

NumPy is essential for handling arrays and matrices in applied mechanics, such as representing force vectors, displacement arrays, or stiffness matrices.

### Vector Operations

Vectors are used for forces, velocities, and moments. NumPy arrays enable efficient operations like addition (resultant forces) and dot/cross products (work or torque).

```python
import numpy as np

# Force vectors in 3D (e.g., in Newtons)
force1 = np.array([10, 20, 0])
force2 = np.array([5, -10, 15])

# Resultant force
resultant = force1 + force2
print(resultant)  # Output: [15 10 15]

# Dot product: Work done by force along a direction (e.g., force1 · force2)
work = np.dot(force1, force2)
print(work)  # Output: -150

# Cross product: Torque (moment) vector
torque = np.cross(force1, force2)
print(torque)  # Output: [ 300 -150 -200]
```

These operations are crucial in statics for equilibrium analysis or in dynamics for momentum calculations.

### Matrix Operations

Matrices represent systems like truss structures or stress tensors. NumPy supports linear algebra for solving equations (e.g., Ax = b for displacements).

```python
import numpy as np

# Stiffness matrix K and force vector F for a simple system
K = np.array([[2, -1], [-1, 2]])  # e.g., for a two-spring system
F = np.array([0, 5])  # Applied forces

# Solve for displacements: x = K^{-1} F
displacements = np.linalg.solve(K, F)
print(displacements)  # Output: [2.5 5. ]
```

This example solves for nodal displacements in a basic finite element or truss problem.

## Matplotlib for Visualizing Mechanics Data

Matplotlib allows plotting of mechanics results, such as stress-strain curves in materials testing or position-time graphs in kinematics.

### Basic Plotting

Plot force vs. displacement for a linear spring (Hooke's law: F = kx).

```python
import numpy as np
import matplotlib.pyplot as plt

# Displacement array (m)
x = np.linspace(0, 0.1, 50)
k = 100  # Spring constant (N/m)
F = k * x  # Force (N)

plt.plot(x, F, label='Force vs. Displacement')
plt.xlabel('Displacement (m)')
plt.ylabel('Force (N)')
plt.title('Hooke\'s Law for a Spring')
plt.legend()
plt.grid(True)
plt.show()
```

This generates a line plot showing a linear relationship, useful for visualizing elastic behavior.

### Advanced Plot: Stress-Strain Curve

For mechanics of materials, plot a typical stress-strain curve for steel.

```python
import numpy as np
import matplotlib.pyplot as plt

# Strain (dimensionless)
strain = np.linspace(0, 0.015, 100)
# Stress (MPa): Linear elastic up to yield, then plastic
yield_strain = 0.002
E = 200000  # Young's modulus (MPa)
yield_stress = E * yield_strain
stress = np.where(strain <= yield_strain, E * strain, yield_stress + 10000 * (strain - yield_strain))

plt.plot(strain, stress, color='blue')
plt.xlabel('Strain')
plt.ylabel('Stress (MPa)')
plt.title('Stress-Strain Curve for Steel')
plt.axvline(x=yield_strain, color='red', linestyle='--', label='Yield Point')
plt.legend()
plt.grid(True)
plt.show()
```

This plot illustrates elastic and plastic regions, with a dashed line at the yield point.

## Numerical Methods with SciPy for Dynamics

SciPy provides tools for numerical integration and solving differential equations, key in dynamics for motion simulation.

### Solving ODEs: Simple Harmonic Motion

Model a mass-spring system: d²x/dt² + ω²x = 0.

```python
import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

def shm(y, t, omega):
    # y = [position, velocity]
    return [y[1], -omega**2 * y[0]]

# Initial conditions: position=1 m, velocity=0 m/s
y0 = [1, 0]
t = np.linspace(0, 10, 100)  # Time array (s)
omega = 1  # Angular frequency (rad/s)

# Solve ODE
sol = odeint(shm, y0, t, args=(omega,))

# Plot position vs. time
plt.plot(t, sol[:, 0], label='Position (m)')
plt.xlabel('Time (s)')
plt.ylabel('Position (m)')
plt.title('Simple Harmonic Motion')
plt.legend()
plt.grid(True)
plt.show()
```

The plot shows oscillatory motion, decaying to equilibrium if damping were added.

## Advanced Unit Handling with Pint for Mechanics

Extend Pint usage to mechanics-specific units, ensuring calculations account for dimensions.

### Force and Torque Conversions

```python
from pint import UnitRegistry

ureg = UnitRegistry()

# Force: Newtons to pounds-force
force_n = 100 * ureg.newton
force_lbf = force_n.to(ureg.lbf)
print(force_lbf)  # Output: 22.480894309999998 pound_force

# Torque: Newton-meters to foot-pounds
torque_nm = 50 * ureg.newton * ureg.meter
torque_ftlb = torque_nm.to(ureg.foot * ureg.pound_force)
print(torque_ftlb)  # Output: 36.878681655 foot * pound_force
```

These conversions are vital in international engineering projects or when using mixed unit systems (SI vs. Imperial).

## Integration Example: Projectile Motion

Combine NumPy, SciPy, and Matplotlib for a dynamics problem: Simulate projectile trajectory under gravity.

```python
import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

def projectile(y, t, g, theta, v0):
    # y = [x, vx, y, vy]
    return [y[1], 0, y[3], -g]

# Initial conditions: Launch at angle theta=45 deg, v0=20 m/s
theta = np.radians(45)
v0 = 20
y0 = [0, v0 * np.cos(theta), 0, v0 * np.sin(theta)]
t = np.linspace(0, 4, 100)  # Time (s)
g = 9.81  # Gravity (m/s²)

# Solve ODE
sol = odeint(projectile, y0, t, args=(g, theta, v0))

# Plot trajectory (x vs. y)
plt.plot(sol[:, 0], sol[:, 2])
plt.xlabel('Horizontal Distance (m)')
plt.ylabel('Vertical Distance (m)')
plt.title('Projectile Trajectory')
plt.grid(True)
plt.show()
```

This simulates and plots the parabolic path, ignoring air resistance.

## Summary

This tutorial applies Python tools to applied mechanics, using NumPy for computations, Matplotlib for visualization, SciPy for numerical methods, and Pint for unit handling. These techniques support analysis in statics, dynamics, and materials. Experiment with parameters or integrate with real data for class projects. For advanced topics, explore SymPy for symbolic mechanics or finite element libraries like FEniCS.